---
const navItems = [
  { href: "/", label: "Home", accent: "#b22c2e" },
  { href: "/teams", label: "Teams", accent: "#ebaa1f" },
  { href: "/about", label: "About", accent: "#b5d9ee" },
  { href: "/insights", label: "Insights", accent: "#4a94ff" },
  { href: "/contact", label: "Contact", accent: "#ebaa1f" }
];

const currentPath = Astro.url.pathname;
const base = import.meta.env.BASE_URL;
const basePath = base.endsWith("/") ? base.slice(0, -1) : base;
const normalizePath = (path) => (path.replace(/\/$/, "") || "/");
const currentNormalized = normalizePath(
  currentPath.startsWith(basePath) ? currentPath.slice(basePath.length) : currentPath
);
const baseWithSlash = base.endsWith("/") ? base : `${base}/`;
const withBase = (path) => `${baseWithSlash}${path.startsWith("/") ? path.slice(1) : path}`;
---

<header id="siteHeader" class="site-header sticky top-0 z-50">
  <div class="section-shell flex h-14 items-center justify-between gap-3 md:h-18">
    <a href={withBase("/")} class="flex items-center gap-3 font-semibold tracking-tight">
      <img
        src={withBase("/logos/simplified-white-text-red-arrow.png")}
        alt="Vista Site Selection"
        class="header-logo-white h-4 w-auto object-contain"
      />
      <img
        src={withBase("/logos/vista-logo-black-red.png")}
        alt="Vista Site Selection"
        class="header-logo-dark h-4 w-auto object-contain"
      />
    </a>

    <!-- Desktop nav (hidden on mobile) -->
    <nav aria-label="Main navigation" class="header-nav-scroll header-nav--desktop">
      <ul class="flex items-center gap-1 text-sm md:gap-2">
        {
          navItems.map((item) => (
            <li>
              <a
                href={withBase(item.href)}
                class={`header-nav-link ${
                  currentNormalized === normalizePath(item.href)
                    ? "header-nav-link--active"
                    : ""
                }`}
              >
                {item.label}
              </a>
            </li>
          ))
        }
      </ul>
    </nav>

    <!-- Mobile hamburger button (hidden on desktop) -->
    <button
      id="mobileMenuBtn"
      class="mobile-menu-btn"
      type="button"
      aria-label="Open navigation menu"
      aria-expanded="false"
    >
      <span class="mobile-menu-btn__line"></span>
      <span class="mobile-menu-btn__line"></span>
      <span class="mobile-menu-btn__line"></span>
    </button>
  </div>

  <!-- Mobile push-down menu — pushes content below it -->
  <div id="mobileDrawer" class="mobile-drawer" aria-hidden="true">
    <nav aria-label="Mobile navigation" class="mobile-drawer__nav">
      {
        navItems.map((item, i) => (
          <a
            href={withBase(item.href)}
            class={`mobile-drawer__link ${
              currentNormalized === normalizePath(item.href)
                ? "mobile-drawer__link--active"
                : ""
            }`}
            data-accent={item.accent}
            style={`--link-accent: ${item.accent}; --link-index: ${i};`}
          >
            <span class="mobile-drawer__link-num">{String(i + 1).padStart(2, "0")}</span>
            <span class="mobile-drawer__link-text">{item.label}</span>
          </a>
        ))
      }
    </nav>
  </div>
</header>

<script>
  const syncHeaderState = () => {
    const header = document.getElementById("siteHeader");
    if (!header) return;
    header.classList.toggle("is-scrolled", window.scrollY > 40);
  };

  syncHeaderState();
  window.addEventListener("scroll", syncHeaderState, { passive: true });
  document.addEventListener("astro:page-load", syncHeaderState);

  // Mobile drawer toggle
  const menuBtn = document.getElementById("mobileMenuBtn");
  const drawer = document.getElementById("mobileDrawer");
  const headerEl = document.getElementById("siteHeader");
  if (menuBtn && drawer) {
    const links = Array.from(drawer.querySelectorAll<HTMLAnchorElement>(".mobile-drawer__link"));

    let closeTimeout: ReturnType<typeof setTimeout> | null = null;

    const toggleDrawer = (open?: boolean) => {
      const shouldOpen = open ?? !drawer.classList.contains("is-open");

      // Clear any pending close animation timeout
      if (closeTimeout) { clearTimeout(closeTimeout); closeTimeout = null; }

      menuBtn.classList.toggle("is-open", shouldOpen);
      menuBtn.setAttribute("aria-expanded", String(shouldOpen));
      drawer.setAttribute("aria-hidden", String(!shouldOpen));
      headerEl?.classList.toggle("is-drawer-open", shouldOpen);
      document.body.classList.toggle("menu-open", shouldOpen);

      if (shouldOpen) {
        // ── OPEN: expand drawer, cascade links in ──
        drawer.classList.remove("is-closing");
        drawer.classList.add("is-open");

        // Staggered cascade — each link slides in 80ms after the previous
        links.forEach((link, i) => {
          link.style.transitionDelay = `${0.08 * i}s`;
          link.classList.add("is-entering");
        });

        // After cascade completes, clear delays so hover transitions are instant
        setTimeout(() => {
          links.forEach(link => {
            link.style.transitionDelay = "0s";
            link.classList.remove("is-entering");
          });
        }, 80 * links.length + 400);

      } else {
        // ── CLOSE: reverse cascade links, then collapse drawer ──
        const totalLinks = links.length;
        links.forEach((link, i) => {
          const reverseI = totalLinks - 1 - i;
          link.style.transitionDelay = `${0.04 * reverseI}s`;
        });

        // Remove is-open so links animate back to hidden
        drawer.classList.remove("is-open");

        // After links cascade out, collapse the drawer height
        const linkCascadeTime = 0.04 * totalLinks * 1000 + 150;
        closeTimeout = setTimeout(() => {
          drawer.classList.add("is-closing");
          setTimeout(() => {
            drawer.classList.remove("is-closing");
            links.forEach(link => {
              link.style.transitionDelay = "0s";
              link.classList.remove("is-entering");
            });
          }, 450);
        }, linkCascadeTime);
      }
    };

    menuBtn.addEventListener("click", () => toggleDrawer());

    // Close on link click
    links.forEach(link => {
      link.addEventListener("click", () => toggleDrawer(false));
    });

    // Close on ESC
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && drawer.classList.contains("is-open")) {
        toggleDrawer(false);
      }
    });

    // No scroll-close needed — drawer is a fixed fullscreen overlay
  }
</script>
